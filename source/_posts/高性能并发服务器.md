---
title: 高性能并发服务器
date: 2024-04-21 16:16:28
tags: 工作/项目
cover: /img/猫猫2.jpg
---

[ubuntu安装vmtools教程以及显示unable to execute]([ubuntu安装wmwaretools教程以及显示 unable to execute "usr/bin/vmware-uninstall-tools.pl"解决办法 - 傻逼离我远点 - 博客园 (cnblogs.com)](https://www.cnblogs.com/jnhs/p/14097576.html))

#### 使用 `<font>` 的标签的修改文字前景色

<font color="red">红色</font>
<font color="green">绿色</font>
<font color="blue">蓝色</font>

<font color="rgb(200, 100, 100)">使用 rgb 颜色值</font>

<font color="#FF00BB">使用十六进制颜色值</font>

## 1. Gcc

![image-20240421163720798](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421163720798.png)

![image-20240421163802549](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421163802549.png)

![image-20240421163903356](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421163903356.png)

![image-20240421164151578](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421164151578.png)

![image-20240421164214532](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421164214532.png)

![image-20240421164359576](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421164359576.png)

## 2. 静态库制作和使用

![image-20240421164514336](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421164514336.png)

***

![image-20240421164609215](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421164609215.png)

![image-20240421164629772](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421164629772.png)

* `cp calc library ../lession06 -r`  将当前文件夹`lession05`下的`calc`和`library`文件复制到上一级目录下的`lession05`中

  ```C
  nowcoder@nowcoder:~/Linux/lession06$ tree
  .
  ├── calc
  │   ├── add.c
  │   ├── add.o
  │   ├── div.c
  │   ├── div.o
  │   ├── head.h
  │   ├── libcalc.a
  │   ├── main.c
  │   ├── mult.c
  │   ├── mult.o
  │   ├── sub.c
  │   └── sub.o
  └── library
      ├── app
      ├── include
      │   └── head.h
      ├── lib
      │   └── libcalc.a
      ├── main.c
      └── src
          ├── add.c
          ├── div.c
          ├── mult.c
          └── sub.c
  
  5 directories, 19 files
  nowcoder@nowcoder:~/Linux/lession06$ cd calc
  nowcoder@nowcoder:~/Linux/lession06/calc$ rm *.o libcalc.a 删除calc下的.o文件和库文件
  ```

## 3. 制作动态库

* 1.制作动态库`gcc -c -fpic add.c div.c sub.c mult.c`

  ​      `gcc -shared *.o -o libcalc.so`

  ![image-20240421165213230](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421165213230.png)

  ![image-20240421165240002](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421165240002.png)

![image-20240421165305089](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421165305089.png)

![image-20240421165527751](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421165527751.png)

* 2. ldd +可执行文件（查看动态库地址加载情况）

     env查看环境变量

     ```C
     nowcoder@nowcoder:~/Linux/lession06/library$ ll
     总用量 36
     drwxrwxr-x 5 nowcoder nowcoder 4096 4月  13 10:52 ./
     drwxrwxr-x 4 nowcoder nowcoder 4096 4月  13 10:16 ../
     drwxrwxr-x 2 nowcoder nowcoder 4096 4月  13 10:16 include/
     drwxrwxr-x 2 nowcoder nowcoder 4096 4月  13 10:43 lib/
     -rwxrwxr-x 1 nowcoder nowcoder 8424 4月  13 10:52 main*
     -rw-rw-r-- 1 nowcoder nowcoder  306 4月  13 10:16 main.c
     drwxrwxr-x 2 nowcoder nowcoder 4096 4月  13 10:16 src/
     nowcoder@nowcoder:~/Linux/lession06/library$ ldd main
     	linux-vdso.so.1 (0x00007fffa132c000)
     	libcalc.so => not found  //<-看这里
     	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f986a129000)
     	/lib64/ld-linux-x86-64.so.2 (0x00007f986a71c000)
     
     ```

### 3.1export添加环境变量（临时）

![image-20240421165835484](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421165835484.png)

`pwd`查看当前文件夹所在路径

```C
nowcoder@nowcoder:~/Linux/lession06/library$ cd lib
nowcoder@nowcoder:~/Linux/lession06/library/lib$ pwd
/home/nowcoder/Linux/lession06/library/lib      //这个就是路径
```

echo命令用于输出变量的值

​	`echo $LD_LIBRARY_PATH:/home/nowcoder/Linux/lession06/library/lib`

### 3.2添加换变量（长期）

![image-20240421170419092](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421170419092.png)

![image-20240421170443780](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421170443780.png)

![image-20240421170507456](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421170507456.png)

![image-20240421170525234](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421170525234.png)

### 3.3动静态库的优缺点

![image-20240421170617522](C:\Users\lin'xin'xin\AppData\Roaming\Typora\typora-user-images\image-20240421170617522.png)

![image-20240421170641672](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421170641672.png)

***



## 4. Makefile

### **4.1 什么是Makefile**

 * 一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中Makefile 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为Makefile 文件就像一个 shel1 脚本一样，也可以执行操作系统的命令。Makefile 带来的好处就是“自动化编译”，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。make 是一个命令工具，是一个解释 Makefile 文件中指令的命令工具，一般来说，大多数的 IDE 都有这个命令比如Delphi的make,VisualC++的nmake,Linux下GNU 的 make。

**4.2 Makefile 文件命名和规则文件命名**



* 文件命名
  makefile 或者Makefile
* Makefile 规则
  * 一个Makefile 文件中可以有一个或者多个规则
    * <font color="red">目标... :  依赖...</font>
      	<font color = "red">命令(shell 命令)</font>
      目标:最终要生成的文件(伪目标除外)
      依赖:生成目标所需要的文件或是目标
      命令:通过执行命令对依赖操作生成目标(命令前必须Tab 缩进)口
    * Makefile 中的其它规则一般都是为第一条规则服务的。

### **4.3 工作原理**

* 命令在执行之前，需要先检查规则中的依赖是否存在

  * 如果存在，执行命令
  * 如果不存在，向不检查其它的规则，检查有没有一个规则是用来生成这个依赖的如果找到了，则执行该规则中的命令

* 检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间

  * 如果依赖的时间比目标的时间晚，需要重新生成目标

  * 如果依赖的时间比目标的时间早，目标不需要更新，对应规则中的命令不需要被执行

### 4.4 自定义变量

![image-20240421171831820](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421171831820.png)

![image-20240421172046159](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421172046159.png)

### 4.5 模式匹配

```C
add.o:add.c
	gcc -c add.c
div.o:div.c
	gcc -c div.c
sub.o:sub.c
	gcc -c sub.c
mult.o:mult.c
	gcc -c mult.c
main.o:main.c
	gcc -c main.c
%.o:%.c
	-%:通配符，匹配一个字符串
	-两个%匹配的是同一个字符串名
%.o:%.c
	gcc -c $< -o $@
```

![image-20240421172502971](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421172502971.png)

### 4.6 函数

* $(wildcard PATTERN...)

  * 功能: 获取指定目录下指定类型的文件列表

  * 参数: PATTERN 指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔

  * 返回:得到的若干个文件的文件列表，文件名之间使用空格间隔

  * 示例:
    `$(wildcard .c ./sub/.c)`

    * 返回值格式: `a.c b.c c.c d.c e.c f.c`

      * ```C
        #定义变量
        #获取指定目录下的.o文件 sub.o add.o mult.o div.o main.o
        src=$(wildcard./*.c)
        target=app
        $(target):$(src)
        		$(CC) $(src) -o $(target)
        %.o:%.c
        		$(CC) -c $< -o $@
        ```

* $(patsubst<pattern>，<replacement>，<text>

  *  功能: 查找<text>中的单词(单词以“空格”、“Tab"或“回车”“换行”分隔)是否符合模式<pattern>，如果匹配的话，则以<replacement>替换。

  * <pattern>可以包括通配符`%`，表示任意长度的字串。如果<replacement>中也包含`%`，那么，<replacement>中的这个`%`将是<pattern>中的那个`%`所代表的字串。(可以用`\`来转义，以`\%`来表示真实含义的`%`字符)

  * 返回: 函数返回被替换过后的字符串

  * 示例:

    * `$(patsubst %.c，%.o，x.c bar.c)`

    * 返回值格式:`x.o bar.o`

    * ```
      #获取指定目录下的.o文件 sub.o add.o mult.o div.o main.o
      src=$(wildcard./*.c)
      objs=$(patsubst %.c,%.o,$(src))
      target=app
      $(target):$(src)
      		$(CC) $(src) -o $(target)
      %.o:%.c
      		$(CC) -c $< -o $@
      		
      ```

      ![image-20240421175808645](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421175808645.png)

    *  touch 文件名——创建文件 

      .PHONY： 文件名O——生成伪目标文件O

    * ![image-20240421175837436](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421175837436.png)

## 5. GBD调试

[linux命令 ll信息详解_ll命令-CSDN博客](https://blog.csdn.net/dshf_1/article/details/99973236)

### 5.1 什么是 GDB

* GDB 是由 GNU 软件系统社区提供的调试工具，同GCC配套组成了一套完整的开发环境，GDB是Linux和许多类Unix系统中的标准开发环境。
* 一般来说，GDB 主要帮助你完成下面四个方面的功能:
  * 1.启动程序，可以按照自定义的要求随心所欲的运行程序
    2.可让被调试的程序在所指定的调置的断点处停住(断点可以是条件表达式)
    3.当程序被停住时，可以检查此时程序中所发生的事
    可以改变程序，将一个 BUG 产生的影响修正从而测试其他BUG4.

### 5.2 准备工作

* 通常，在为调试而编译时，我们会()关掉编译器的优化选项(-o)，并打开调试选项(-g)。另外，`-wa11`在尽量不影响程序行为的情况下选项打开所有`warning`，也可以发现许多问题，避免一些不必要的BUG。

* `gcc -g-Wall program.c o program`

* `-g`选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证 gdb 能找到源文件。

  ```C
  nowcoder@nowcoder:~/Linux/lession08$ gcc test.c -o test -g
  nowcoder@nowcoder:~/Linux/lession08$ gcc test.c -o test1
  nowcoder@nowcoder:~/Linux/lession08$ ll -h
  总用量 52K
  -rwxrwxr-x 1 nowcoder nowcoder  11K 4月  14 20:26 test*
  -rwxrwxr-x 1 nowcoder nowcoder 8.3K 4月  14 20:26 test1*
  ```

  

### 5.3 GDB命令-启动、推出、查看代码

* **启动和退出**
  gdb 可执行程序

  quit

* **给程序设置参数**/**获取设置参数**
  set args 1020
  show args

* **GDB** **使用帮助**
  help

* **查看当前文件代码**

  list/1 (从默认位置显示)
  list/1行号 (从指定的行显示)
  list/1 函数名(从指定的函数显示)

* **查看非当前文件代码**

  list/l 文件名:行号

  list/l 文件名:函数名

* **设置显示的行数**
  show list/listsize
  set list/listsize 行数

```c
(gdb) list
1	#include <stdio.h>
2	#include <stdlib.h>
3
4	int test(int a);
5	
6	int main(int argc, char* argv[]) {
7	    int a, b;
8	    printf("argc = %d\n", argc);
9	
10	    if(argc < 3) {
(gdb) l 20
15	        b = atoi(argv[2]);
16	    }
17	    printf("a = %d, b = %d\n", a, b);
18	    printf("a + b = %d\n", a + b);
19	
20	    for(int i = 0; i < a; ++i) {
21	        printf("i = %d\n", i);
22	        // 函数调用
23	        int res = test(i);
24	        printf("res value: %d\n", res);
(gdb) list main
1	#include <stdio.h>
2	#include <stdlib.h>
3	
4	int test(int a);
5	
6	int main(int argc, char* argv[]) {
7	    int a, b;
8	    printf("argc = %d\n", argc);
9	
10	    if(argc < 3) {

```

### 5.4 GBD命令-断点操作

![image-20240421181214061](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421181214061.png)

```c
(gdb) break 9
Breakpoint 1 at 0xb2c: file main.cpp, line 9.
(gdb) b main
Breakpoint 2 at 0xafa: file main.cpp, line 6.
b bubble.cpp:11
Breakpoint 3 at 0xa18: file bubble.cpp, line 11.
 b bubble.cpp:bubbleSort
Breakpoint 4 at 0x9b5: file bubble.cpp, line 8.
(gdb) i b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000000b2c in main() at main.cpp:9
2       breakpoint     keep y   0x0000000000000afa in main() at main.cpp:6
3       breakpoint     keep y   0x0000000000000a18 in bubbleSort(int*, int) 
                                                   at bubble.cpp:11
4       breakpoint     keep y   0x00000000000009b5 in bubbleSort(int*, int) 
                                                   at bubble.cpp:8

```

### 5.5 GBD命令-调试命令

![image-20240421181324553](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421181324553.png)

***



## 6. 文件I/O（针对内存而言）

### 6.1 标准C库IO函数

1、标准C库I/O函数与Linux系统I/O函数的区别

（1）标准C库I/O函数在读写的时候，中间有一个缓冲区，而Linux系统I/O函数没有缓冲区；如果中间有缓冲区的话在进行读写操作的时候会先存到缓冲区，再刷新到磁盘，它比直接逐条读写到磁盘效率要高。

（2）根据应用场景选择合适的I/O函数，如：再进行网络通信时就应该使用Linux系统I/O函数，因为通信更要求实时性；而在对磁盘进行读写时则选择标准C库I/O函数。

[标准C库I/O函数与Linux系统I/O函数对比（通俗易懂）_标准c库io函数和linux系统io函数对比-CSDN博客](https://blog.csdn.net/weixin_47156401/article/details/125658799)

![image-20240421181551255](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421181551255.png)

![image-20240421181628087](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421181628087.png)

### 6.2 标准C库IO和Linux系统和IO关系

[68-文件I/O：标准C库IO函数和Linux系统IO函数对比-CSDN博客](https://blog.csdn.net/Edward_LF/article/details/124398047#:~:text=标准c库函数和linux系统函数区别： 标准c库可以跨平台；（调用了不同平台的系统API）,在linux平台中，调用c库函数，底层是调用的是linux中的系统函数 linux系统I%2FO函数是没有缓冲区的，调用一次就会访问一次)

![image-20240421181845943](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421181845943.png)

### 6.3 虚拟地址空间

* 一个进程对应一个虚拟地址空间，由CPU中的MMU内存管理映射到真实的物理地址，程序（.c、.exe）并不占用内存空间，只占用磁盘空间。进程占用内存。文件描述符在内核区。
* ![image-20240421182111634](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421182111634.png)

### 6.4 文件描述符

![image-20240421182153263](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421182153263.png)

### 6.5 open打开文件



```c
<font color='green'>/*open 打开文件</font>

 <font color='green'> \#include <sys/types.h></font>

 <font color='green'> \#include <sys/stat.h></font>

  <font color='green'>\#include <fcntl.h></font>

 <font color='green'> // 打开一个已经存在的文件</font>

 <font color='green'> int open(const char *pathname, int flags);</font>

    <font color='green'>参数：</font>

    <font color='green'>  \- pathname：要打开的文件路径</font>

    <font color='green'>  \- flags：对文件的操作权限设置还有其他的设置</font>

      <font color='green'> O_RDONLY,  O_WRONLY, O_RDWR  这三个设置是互斥的</font>

    <font color='green'>返回值：返回一个新的文件描述符，如果调用失败，返回-1</font>

 <font color='green'> errno：属于Linux系统函数库，库里面的一个全局变量，记录的是最近的错误号。</font>

  <font color='green'>\#include <stdio.h></font>

 <font color='green'> void perror(const char *s);作用：打印errno对应的错误描述</font>

    <font color='green'>s参数：用户描述，比如hello,最终输出的内容是  hello:xxx(实际的错误描述)</font>

  

  <font color='green'>// 创建一个新的文件</font>

  <font color='green'>int open(c/usr/bin/gcconst char *pathname, int flags, mode_t mode);</font>

<font color='green'>*/</font>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
int main() {
    // 打开一个文件
    int fd = open("a.txt", O_RDONLY);
    if(fd == -1) {
        perror("open");
    }
    // 读写操作
    // 关闭
    close(fd);
    return 0;
}
```



### 6.6 open创建新文件
```c
/*open创建新文件

  \#include <sys/types.h>

  \#include <sys/stat.h>

  \#include <fcntl.h>

  int open(const char *pathname, int flags, mode_t mode);

    参数：

      \- pathname：要创建的文件的路径

      \- flags：对文件的操作权限和其他的设置

        \- 必选项：O_RDONLY, O_WRONLY, O_RDWR  这三个之间是互斥的

        \- 可选项：O_CREAT 文件不存在，创建新文件
      \- mode：八进制的数，表示创建出的新的文件的操作权限，比如：0775

      最终的权限是：mode & ~umask

      0777  ->  111111111

    &  0775  ->  111111101

    \----------------------------

            111111101

    按位与：0和任何数都为0

   umask的作用就是抹去某些权限。

   flags参数是一个int类型的数据，占4个字节，32位。

   flags 32个位，每一位就是一个标志位。

*/

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
int main() {
    // 创建一个新的文件
    int fd = open("create.txt", O_RDWR | O_CREAT, 0777);| O_CREAT创建文件的新标志
    if(fd == -1) {
        perror("open");
    }
    // 关闭
    close(fd);
    return 0;
}
```

### 6.5 Linux系统i/o函数

![image-20240421201504240](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421201504240.png)

* **read函数**读取数据是指从文件中读取数据到内存中

* **write函数**写数据是指把内存中数据写到文件中

```c
/*  
    #include <unistd.h>
    ssize_t read(int fd, void *buf, size_t count);
        参数：
            - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件
            - buf：需要读取数据存放的地方，数组的地址（传出参数）
            - count：指定的数组的大小
        返回值：
            - 成功：
                >0: 返回实际的读取到的字节数
                =0：文件已经读取完了
            - 失败：-1 ，并且设置errno
    #include <unistd.h>
    ssize_t write(int fd, const void *buf, size_t count);
        参数：
            - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件
            - buf：要往磁盘写入的数据，数组
            - count：要写的数据的实际的大小
        返回值：
            成功：实际写入的字节数
            失败：返回-1，并设置errno
*/
#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int main() {
    // 1.通过open打开english.txt文件
    int srcfd = open("english.txt", O_RDONLY);
    if(srcfd == -1) {
        perror("open");
        return -1;
    }
    // 2.创建一个新的文件（拷贝文件）
    int destfd = open("cpy.txt", O_WRONLY | O_CREAT, 0664);
    if(destfd == -1) {
        perror("open");
        return -1;
    }
    // 3.频繁的读写操作
    char buf[1024] = {0};
    int len = 0;
    while((len = read(srcfd, buf, sizeof(buf))) > 0) {
        write(destfd, buf, len);
    }
    // 4.关闭文件
    close(destfd);
    close(srcfd);

    return 0;
}

```

### 6.6lseek函数

——移动文件指针到文件头、获取当前文件指针的位置、获取文件长度、拓展文件的长度

```c
/*  
    标准C库的函数
    #include <stdio.h>
    int fseek(FILE *stream, long offset, int whence);

    Linux系统函数
    #include <sys/types.h>
    #include <unistd.h>
    off_t lseek(int fd, off_t offset, int whence);
        参数：
            - fd：文件描述符，通过open得到的，通过这个fd操作某个文件
            - offset：偏移量
            - whence:
                SEEK_SET
                    设置文件指针的偏移量
                SEEK_CUR
                    设置偏移量：当前位置 + 第二个参数offset的值
                SEEK_END
                    设置偏移量：文件大小 + 第二个参数offset的值
        返回值：返回文件指针的位置


    作用：
        1.移动文件指针到文件头
        lseek(fd, 0, SEEK_SET);

        2.获取当前文件指针的位置
        lseek(fd, 0, SEEK_CUR);

        3.获取文件长度
        lseek(fd, 0, SEEK_END);

        4.拓展文件的长度，当前文件10b, 110b, 增加了100个字节
        lseek(fd, 100, SEEK_END)
        注意：需要写一次数据

*/

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main() {

    int fd = open("hello.txt", O_RDWR);

    if(fd == -1) {
        perror("open");
        return -1;
    }

    // 扩展文件的长度
    int ret = lseek(fd, 100, SEEK_END);
    if(ret == -1) {
        perror("lseek");
        return -1;
    }

    // 写入一个空数据
    write(fd, " ", 1);

    // 关闭文件
    close(fd);

    return 0;
}

```



### 6.6 lstat函数和stat函数

——获取一个文件相关的一些信息

```c
//stat 结构体
struct stat{
dev_t		st_dev;		// 文件的设备编号
ino_t		st_ino;		// 节点
mode_t		st_mode;	//文件的类型和存取的权限
nlink_t		st_nlink;	//连到该文件的硬连接数目
uid_t		st_uid;		//用户ID
gid_t		st_gid;		//组ID
dev_t		st_rdev;	//设备文件的设备编号
off_t		st_size;	//文件字节数(文件大小)
blksize_t	st_blksize;	//块大小
blkcnt_t	st_blocks;	//块数
time_t		st_atime;	//最后一次访问时间
time_t		st_mtime;	//最后一次修改时间
time_t		st_ctime;	//最后一次改变时间(指属性
```

```c
/*
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <unistd.h>

       int stat(const char *pathname, struct stat *statbuf);
       作用：获取一个文件相关的一些信息
       参数：
            -pathname:操作文件的路径
            -statbuf：结构体变量，传出参数，用于保存获取到的文件信息
        返回值:
        成功：返回0；
        失败：返回-1，并设置errno；
       int lstat(const char *pathname, struct stat *statbuf);
       作用：获取软连接文件相关的一些信息
       参数：
            -pathname:操作文件的路径
            -statbuf：结构体变量，传出参数，用于保存获取到的文件信息
        返回值:
        成功：返回0；
        失败：返回-1，并设置errno；
*/
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>

int main() {

    struct stat statbuf;

    int ret = stat("a.txt", &statbuf);

    if(ret == -1) {
        perror("stat");
        return -1;
    }

    printf("size: %ld\n", statbuf.st_size);


    return 0;
}
```

* 判断权限，应该和相应的宏与&操作；判断文件类型，将mode与掩码与&操作，再和宏进行比较![image-20240421204638015](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421204638015.png)

### 6.7模拟实现ls-l命令

——ls-l命令能够获取当前目录下文件的信息

​	ls-l xx.txt查看当前xx文件的信息

### 6.8 文件属性操作函数

```c
int access(const char *pathname, int mode);
int chmod(const char *filename, int mode);
int chown(const char *path, uid_t owner, gid_t group);
int truncate(const char *path, off_t length);
```

1.int access(const char *pathname, int mode);

——作用：判断某个文件是否具有某个权限，或者判断文件是否存在

 
