---
title: 高性能并发服务器
date: 2024-04-21 16:16:28
tags: 工作/项目
cover: /img/猫猫2.jpg
---

[ubuntu安装vmtools教程以及显示unable to execute]([ubuntu安装wmwaretools教程以及显示 unable to execute "usr/bin/vmware-uninstall-tools.pl"解决办法 - 傻逼离我远点 - 博客园 (cnblogs.com)](https://www.cnblogs.com/jnhs/p/14097576.html))

#### 使用 `<font>` 的标签的修改文字前景色

<font color="red">红色</font>
<font color="green">绿色</font>
<font color="blue">蓝色</font>

<font color="rgb(200, 100, 100)">使用 rgb 颜色值</font>

<font color="#FF00BB">使用十六进制颜色值</font>

## 1. Gcc

![image-20240421163720798](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421163720798.png)

![image-20240421163802549](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421163802549.png)

![image-20240421163903356](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421163903356.png)

![image-20240421164151578](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421164151578.png)

![image-20240421164214532](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421164214532.png)

![image-20240421164359576](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421164359576.png)

## 2. 静态库制作和使用

![image-20240421164514336](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421164514336.png)

***

![image-20240421164609215](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421164609215.png)

![image-20240421164629772](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421164629772.png)

* `cp calc library ../lession06 -r`  将当前文件夹`lession05`下的`calc`和`library`文件复制到上一级目录下的`lession05`中

  ```C
  nowcoder@nowcoder:~/Linux/lession06$ tree
  .
  ├── calc
  │   ├── add.c
  │   ├── add.o
  │   ├── div.c
  │   ├── div.o
  │   ├── head.h
  │   ├── libcalc.a
  │   ├── main.c
  │   ├── mult.c
  │   ├── mult.o
  │   ├── sub.c
  │   └── sub.o
  └── library
      ├── app
      ├── include
      │   └── head.h
      ├── lib
      │   └── libcalc.a
      ├── main.c
      └── src
          ├── add.c
          ├── div.c
          ├── mult.c
          └── sub.c
  
  5 directories, 19 files
  nowcoder@nowcoder:~/Linux/lession06$ cd calc
  nowcoder@nowcoder:~/Linux/lession06/calc$ rm *.o libcalc.a 删除calc下的.o文件和库文件
  ```

## 3. 制作动态库

* 1.制作动态库`gcc -c -fpic add.c div.c sub.c mult.c`

  ​      `gcc -shared *.o -o libcalc.so`

  ![image-20240421165213230](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421165213230.png)

  ![image-20240421165240002](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421165240002.png)

![image-20240421165305089](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421165305089.png)

![image-20240421165527751](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421165527751.png)

* 2. ldd +可执行文件（查看动态库地址加载情况）

     env查看环境变量

     ```C
     nowcoder@nowcoder:~/Linux/lession06/library$ ll
     总用量 36
     drwxrwxr-x 5 nowcoder nowcoder 4096 4月  13 10:52 ./
     drwxrwxr-x 4 nowcoder nowcoder 4096 4月  13 10:16 ../
     drwxrwxr-x 2 nowcoder nowcoder 4096 4月  13 10:16 include/
     drwxrwxr-x 2 nowcoder nowcoder 4096 4月  13 10:43 lib/
     -rwxrwxr-x 1 nowcoder nowcoder 8424 4月  13 10:52 main*
     -rw-rw-r-- 1 nowcoder nowcoder  306 4月  13 10:16 main.c
     drwxrwxr-x 2 nowcoder nowcoder 4096 4月  13 10:16 src/
     nowcoder@nowcoder:~/Linux/lession06/library$ ldd main
     	linux-vdso.so.1 (0x00007fffa132c000)
     	libcalc.so => not found  //<-看这里
     	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f986a129000)
     	/lib64/ld-linux-x86-64.so.2 (0x00007f986a71c000)
     
     ```

### 3.1export添加环境变量（临时）

![image-20240421165835484](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421165835484.png)

`pwd`查看当前文件夹所在路径

```C
nowcoder@nowcoder:~/Linux/lession06/library$ cd lib
nowcoder@nowcoder:~/Linux/lession06/library/lib$ pwd
/home/nowcoder/Linux/lession06/library/lib      //这个就是路径
```

echo命令用于输出变量的值

​	`echo $LD_LIBRARY_PATH:/home/nowcoder/Linux/lession06/library/lib`

### 3.2添加换变量（长期）

![image-20240421170419092](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421170419092.png)

![image-20240421170443780](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421170443780.png)

![image-20240421170507456](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421170507456.png)

![image-20240421170525234](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421170525234.png)

### 3.3动静态库的优缺点

![image-20240421170617522](C:\Users\lin'xin'xin\AppData\Roaming\Typora\typora-user-images\image-20240421170617522.png)

![image-20240421170641672](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421170641672.png)

***



## 4. Makefile

### **4.1 什么是Makefile**

 * 一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中Makefile 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为Makefile 文件就像一个 shel1 脚本一样，也可以执行操作系统的命令。Makefile 带来的好处就是“自动化编译”，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。make 是一个命令工具，是一个解释 Makefile 文件中指令的命令工具，一般来说，大多数的 IDE 都有这个命令比如Delphi的make,VisualC++的nmake,Linux下GNU 的 make。

**4.2 Makefile 文件命名和规则文件命名**



* 文件命名
  makefile 或者Makefile
* Makefile 规则
  * 一个Makefile 文件中可以有一个或者多个规则
    * <font color="red">目标... :  依赖...</font>
      	<font color = "red">命令(shell 命令)</font>
      目标:最终要生成的文件(伪目标除外)
      依赖:生成目标所需要的文件或是目标
      命令:通过执行命令对依赖操作生成目标(命令前必须Tab 缩进)口
    * Makefile 中的其它规则一般都是为第一条规则服务的。

### **4.3 工作原理**

* 命令在执行之前，需要先检查规则中的依赖是否存在

  * 如果存在，执行命令
  * 如果不存在，向不检查其它的规则，检查有没有一个规则是用来生成这个依赖的如果找到了，则执行该规则中的命令

* 检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间

  * 如果依赖的时间比目标的时间晚，需要重新生成目标

  * 如果依赖的时间比目标的时间早，目标不需要更新，对应规则中的命令不需要被执行

### 4.4 自定义变量

![image-20240421171831820](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421171831820.png)

![image-20240421172046159](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421172046159.png)

### 4.5 模式匹配

```C
add.o:add.c
	gcc -c add.c
div.o:div.c
	gcc -c div.c
sub.o:sub.c
	gcc -c sub.c
mult.o:mult.c
	gcc -c mult.c
main.o:main.c
	gcc -c main.c
%.o:%.c
	-%:通配符，匹配一个字符串
	-两个%匹配的是同一个字符串名
%.o:%.c
	gcc -c $< -o $@
```

![image-20240421172502971](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421172502971.png)

### 4.6 函数

* $(wildcard PATTERN...)

  * 功能: 获取指定目录下指定类型的文件列表

  * 参数: PATTERN 指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔

  * 返回:得到的若干个文件的文件列表，文件名之间使用空格间隔

  * 示例:
    `$(wildcard .c ./sub/.c)`

    * 返回值格式: `a.c b.c c.c d.c e.c f.c`

      * ```C
        #定义变量
        #获取指定目录下的.o文件 sub.o add.o mult.o div.o main.o
        src=$(wildcard./*.c)
        target=app
        $(target):$(src)
        		$(CC) $(src) -o $(target)
        %.o:%.c
        		$(CC) -c $< -o $@
        ```

* $(patsubst<pattern>，<replacement>，<text>

  *  功能: 查找<text>中的单词(单词以“空格”、“Tab"或“回车”“换行”分隔)是否符合模式<pattern>，如果匹配的话，则以<replacement>替换。

  * <pattern>可以包括通配符`%`，表示任意长度的字串。如果<replacement>中也包含`%`，那么，<replacement>中的这个`%`将是<pattern>中的那个`%`所代表的字串。(可以用`\`来转义，以`\%`来表示真实含义的`%`字符)

  * 返回: 函数返回被替换过后的字符串

  * 示例:

    * `$(patsubst %.c，%.o，x.c bar.c)`

    * 返回值格式:`x.o bar.o`

    * ```
      #获取指定目录下的.o文件 sub.o add.o mult.o div.o main.o
      src=$(wildcard./*.c)
      objs=$(patsubst %.c,%.o,$(src))
      target=app
      $(target):$(src)
      		$(CC) $(src) -o $(target)
      %.o:%.c
      		$(CC) -c $< -o $@
      		
      ```

      ![image-20240421175808645](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421175808645.png)

    *  touch 文件名——创建文件 

      .PHONY： 文件名O——生成伪目标文件O

    * ![image-20240421175837436](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421175837436.png)

## 5. GBD调试

[linux命令 ll信息详解_ll命令-CSDN博客](https://blog.csdn.net/dshf_1/article/details/99973236)

### 5.1 什么是 GDB

* GDB 是由 GNU 软件系统社区提供的调试工具，同GCC配套组成了一套完整的开发环境，GDB是Linux和许多类Unix系统中的标准开发环境。
* 一般来说，GDB 主要帮助你完成下面四个方面的功能:
  * 1.启动程序，可以按照自定义的要求随心所欲的运行程序
    2.可让被调试的程序在所指定的调置的断点处停住(断点可以是条件表达式)
    3.当程序被停住时，可以检查此时程序中所发生的事
    可以改变程序，将一个 BUG 产生的影响修正从而测试其他BUG4.

### 5.2 准备工作

* 通常，在为调试而编译时，我们会()关掉编译器的优化选项(-o)，并打开调试选项(-g)。另外，`-wa11`在尽量不影响程序行为的情况下选项打开所有`warning`，也可以发现许多问题，避免一些不必要的BUG。

* `gcc -g-Wall program.c o program`

* `-g`选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证 gdb 能找到源文件。

  ```C
  nowcoder@nowcoder:~/Linux/lession08$ gcc test.c -o test -g
  nowcoder@nowcoder:~/Linux/lession08$ gcc test.c -o test1
  nowcoder@nowcoder:~/Linux/lession08$ ll -h
  总用量 52K
  -rwxrwxr-x 1 nowcoder nowcoder  11K 4月  14 20:26 test*
  -rwxrwxr-x 1 nowcoder nowcoder 8.3K 4月  14 20:26 test1*
  ```

  

### 5.3 GDB命令-启动、推出、查看代码

* **启动和退出**
  gdb 可执行程序

  quit

* **给程序设置参数**/**获取设置参数**
  set args 1020
  show args

* **GDB** **使用帮助**
  help

* **查看当前文件代码**

  list/1 (从默认位置显示)
  list/1行号 (从指定的行显示)
  list/1 函数名(从指定的函数显示)

* **查看非当前文件代码**

  list/l 文件名:行号

  list/l 文件名:函数名

* **设置显示的行数**
  show list/listsize
  set list/listsize 行数

```c
(gdb) list
1	#include <stdio.h>
2	#include <stdlib.h>
3
4	int test(int a);
5	
6	int main(int argc, char* argv[]) {
7	    int a, b;
8	    printf("argc = %d\n", argc);
9	
10	    if(argc < 3) {
(gdb) l 20
15	        b = atoi(argv[2]);
16	    }
17	    printf("a = %d, b = %d\n", a, b);
18	    printf("a + b = %d\n", a + b);
19	
20	    for(int i = 0; i < a; ++i) {
21	        printf("i = %d\n", i);
22	        // 函数调用
23	        int res = test(i);
24	        printf("res value: %d\n", res);
(gdb) list main
1	#include <stdio.h>
2	#include <stdlib.h>
3	
4	int test(int a);
5	
6	int main(int argc, char* argv[]) {
7	    int a, b;
8	    printf("argc = %d\n", argc);
9	
10	    if(argc < 3) {

```

### 5.4 GBD命令-断点操作

![image-20240421181214061](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421181214061.png)

```c
(gdb) break 9
Breakpoint 1 at 0xb2c: file main.cpp, line 9.
(gdb) b main
Breakpoint 2 at 0xafa: file main.cpp, line 6.
b bubble.cpp:11
Breakpoint 3 at 0xa18: file bubble.cpp, line 11.
 b bubble.cpp:bubbleSort
Breakpoint 4 at 0x9b5: file bubble.cpp, line 8.
(gdb) i b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000000b2c in main() at main.cpp:9
2       breakpoint     keep y   0x0000000000000afa in main() at main.cpp:6
3       breakpoint     keep y   0x0000000000000a18 in bubbleSort(int*, int) 
                                                   at bubble.cpp:11
4       breakpoint     keep y   0x00000000000009b5 in bubbleSort(int*, int) 
                                                   at bubble.cpp:8

```

### 5.5 GBD命令-调试命令

![image-20240421181324553](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421181324553.png)

***



## 6. 文件I/O（针对内存而言）

### 6.1 标准C库IO函数

1、标准C库I/O函数与Linux系统I/O函数的区别

（1）标准C库I/O函数在读写的时候，中间有一个缓冲区，而Linux系统I/O函数没有缓冲区；如果中间有缓冲区的话在进行读写操作的时候会先存到缓冲区，再刷新到磁盘，它比直接逐条读写到磁盘效率要高。

（2）根据应用场景选择合适的I/O函数，如：再进行网络通信时就应该使用Linux系统I/O函数，因为通信更要求实时性；而在对磁盘进行读写时则选择标准C库I/O函数。

[标准C库I/O函数与Linux系统I/O函数对比（通俗易懂）_标准c库io函数和linux系统io函数对比-CSDN博客](https://blog.csdn.net/weixin_47156401/article/details/125658799)

![image-20240421181551255](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421181551255.png)

![image-20240421181628087](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421181628087.png)

### 6.2 标准C库IO和Linux系统和IO关系

[68-文件I/O：标准C库IO函数和Linux系统IO函数对比-CSDN博客](https://blog.csdn.net/Edward_LF/article/details/124398047#:~:text=标准c库函数和linux系统函数区别： 标准c库可以跨平台；（调用了不同平台的系统API）,在linux平台中，调用c库函数，底层是调用的是linux中的系统函数 linux系统I%2FO函数是没有缓冲区的，调用一次就会访问一次)

![image-20240421181845943](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421181845943.png)

### 6.3 虚拟地址空间

* 一个进程对应一个虚拟地址空间，由CPU中的MMU内存管理映射到真实的物理地址，程序（.c、.exe）并不占用内存空间，只占用磁盘空间。进程占用内存。文件描述符在内核区。
* ![image-20240421182111634](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421182111634.png)

### 6.4 文件描述符

![image-20240421182153263](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421182153263.png)

### 6.5 open打开文件



```c
<font color='green'>/*open 打开文件</font>

 <font color='green'> \#include <sys/types.h></font>

 <font color='green'> \#include <sys/stat.h></font>

  <font color='green'>\#include <fcntl.h></font>

 <font color='green'> // 打开一个已经存在的文件</font>

 <font color='green'> int open(const char *pathname, int flags);</font>

    <font color='green'>参数：</font>

    <font color='green'>  \- pathname：要打开的文件路径</font>

    <font color='green'>  \- flags：对文件的操作权限设置还有其他的设置</font>

      <font color='green'> O_RDONLY,  O_WRONLY, O_RDWR  这三个设置是互斥的</font>

    <font color='green'>返回值：返回一个新的文件描述符，如果调用失败，返回-1</font>

 <font color='green'> errno：属于Linux系统函数库，库里面的一个全局变量，记录的是最近的错误号。</font>

  <font color='green'>\#include <stdio.h></font>

 <font color='green'> void perror(const char *s);作用：打印errno对应的错误描述</font>

    <font color='green'>s参数：用户描述，比如hello,最终输出的内容是  hello:xxx(实际的错误描述)</font>

  

  <font color='green'>// 创建一个新的文件</font>

  <font color='green'>int open(c/usr/bin/gcconst char *pathname, int flags, mode_t mode);</font>

<font color='green'>*/</font>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
int main() {
    // 打开一个文件
    int fd = open("a.txt", O_RDONLY);
    if(fd == -1) {
        perror("open");
    }
    // 读写操作
    // 关闭
    close(fd);
    return 0;
}
```



### 6.6 open创建新文件
```c
/*open创建新文件

  \#include <sys/types.h>

  \#include <sys/stat.h>

  \#include <fcntl.h>

  int open(const char *pathname, int flags, mode_t mode);

    参数：

      \- pathname：要创建的文件的路径

      \- flags：对文件的操作权限和其他的设置

        \- 必选项：O_RDONLY, O_WRONLY, O_RDWR  这三个之间是互斥的

        \- 可选项：O_CREAT 文件不存在，创建新文件
      \- mode：八进制的数，表示创建出的新的文件的操作权限，比如：0775

      最终的权限是：mode & ~umask

      0777  ->  111111111

    &  0775  ->  111111101

    \----------------------------

            111111101

    按位与：0和任何数都为0

   umask的作用就是抹去某些权限。

   flags参数是一个int类型的数据，占4个字节，32位。

   flags 32个位，每一位就是一个标志位。

*/

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
int main() {
    // 创建一个新的文件
    int fd = open("create.txt", O_RDWR | O_CREAT, 0777);| O_CREAT创建文件的新标志
    if(fd == -1) {
        perror("open");
    }
    // 关闭
    close(fd);
    return 0;
}
```

### 6.5 Linux系统i/o函数

![image-20240421201504240](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421201504240.png)

* **read函数**读取数据是指从文件中读取数据到内存中

* **write函数**写数据是指把内存中数据写到文件中

```c
/*  
    #include <unistd.h>
    ssize_t read(int fd, void *buf, size_t count);
        参数：
            - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件
            - buf：需要读取数据存放的地方，数组的地址（传出参数）
            - count：指定的数组的大小
        返回值：
            - 成功：
                >0: 返回实际的读取到的字节数
                =0：文件已经读取完了
            - 失败：-1 ，并且设置errno
    #include <unistd.h>
    ssize_t write(int fd, const void *buf, size_t count);
        参数：
            - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件
            - buf：要往磁盘写入的数据，数组
            - count：要写的数据的实际的大小
        返回值：
            成功：实际写入的字节数
            失败：返回-1，并设置errno
*/
#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int main() {
    // 1.通过open打开english.txt文件
    int srcfd = open("english.txt", O_RDONLY);
    if(srcfd == -1) {
        perror("open");
        return -1;
    }
    // 2.创建一个新的文件（拷贝文件）
    int destfd = open("cpy.txt", O_WRONLY | O_CREAT, 0664);
    if(destfd == -1) {
        perror("open");
        return -1;
    }
    // 3.频繁的读写操作
    char buf[1024] = {0};
    int len = 0;
    while((len = read(srcfd, buf, sizeof(buf))) > 0) {
        write(destfd, buf, len);
    }
    // 4.关闭文件
    close(destfd);
    close(srcfd);

    return 0;
}

```

### 6.6lseek函数

——移动文件指针到文件头、获取当前文件指针的位置、获取文件长度、拓展文件的长度

```c
/*  
    标准C库的函数
    #include <stdio.h>
    int fseek(FILE *stream, long offset, int whence);

    Linux系统函数
    #include <sys/types.h>
    #include <unistd.h>
    off_t lseek(int fd, off_t offset, int whence);
        参数：
            - fd：文件描述符，通过open得到的，通过这个fd操作某个文件
            - offset：偏移量
            - whence:
                SEEK_SET
                    设置文件指针的偏移量
                SEEK_CUR
                    设置偏移量：当前位置 + 第二个参数offset的值
                SEEK_END
                    设置偏移量：文件大小 + 第二个参数offset的值
        返回值：返回文件指针的位置


    作用：
        1.移动文件指针到文件头
        lseek(fd, 0, SEEK_SET);

        2.获取当前文件指针的位置
        lseek(fd, 0, SEEK_CUR);

        3.获取文件长度
        lseek(fd, 0, SEEK_END);

        4.拓展文件的长度，当前文件10b, 110b, 增加了100个字节
        lseek(fd, 100, SEEK_END)
        注意：需要写一次数据

*/

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main() {

    int fd = open("hello.txt", O_RDWR);

    if(fd == -1) {
        perror("open");
        return -1;
    }

    // 扩展文件的长度
    int ret = lseek(fd, 100, SEEK_END);
    if(ret == -1) {
        perror("lseek");
        return -1;
    }

    // 写入一个空数据
    write(fd, " ", 1);

    // 关闭文件
    close(fd);

    return 0;
}

```



### 6.6 lstat函数和stat函数

——获取一个文件相关的一些信息

```c
//stat 结构体
struct stat{
dev_t		st_dev;		// 文件的设备编号
ino_t		st_ino;		// 节点
mode_t		st_mode;	//文件的类型和存取的权限
nlink_t		st_nlink;	//连到该文件的硬连接数目
uid_t		st_uid;		//用户ID
gid_t		st_gid;		//组ID
dev_t		st_rdev;	//设备文件的设备编号
off_t		st_size;	//文件字节数(文件大小)
blksize_t	st_blksize;	//块大小
blkcnt_t	st_blocks;	//块数
time_t		st_atime;	//最后一次访问时间
time_t		st_mtime;	//最后一次修改时间
time_t		st_ctime;	//最后一次改变时间(指属性
```

```c
/*
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <unistd.h>

       int stat(const char *pathname, struct stat *statbuf);
       作用：获取一个文件相关的一些信息
       参数：
            -pathname:操作文件的路径
            -statbuf：结构体变量，传出参数，用于保存获取到的文件信息
        返回值:
        成功：返回0；
        失败：返回-1，并设置errno；
       int lstat(const char *pathname, struct stat *statbuf);
       作用：获取软连接文件相关的一些信息
       参数：
            -pathname:操作文件的路径
            -statbuf：结构体变量，传出参数，用于保存获取到的文件信息
        返回值:
        成功：返回0；
        失败：返回-1，并设置errno；
*/
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>

int main() {

    struct stat statbuf;

    int ret = stat("a.txt", &statbuf);

    if(ret == -1) {
        perror("stat");
        return -1;
    }

    printf("size: %ld\n", statbuf.st_size);


    return 0;
}
```

* 判断权限，应该和相应的宏与&操作；判断文件类型，将mode与掩码与&操作，再和宏进行比较![image-20240421204638015](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421204638015.png)

### 6.7模拟实现ls-l命令

——ls-l命令能够获取当前目录下文件的信息

​	ls-l xx.txt查看当前xx文件的信息

2024/04/21

### 6.8 文件属性操作函数

```c
int access(const char *pathname, int mode);
int chmod(const char *filename, int mode);
int chown(const char *path, uid_t owner, gid_t group);
int truncate(const char *path, off_t length);
```

1. **int access(const char *pathname, int mode);**

​	——作用：判断某个文件是否具有某个权限，或者判断文件是否存在

​	——参数：

​      \- pathname: 判断的文件路径

​      \- mode:

​        R_OK: 判断是否有读权限

​        W_OK: 判断是否有写权限

​        X_OK: 判断是否有执行权限

​        F_OK: 判断文件是否存在

​       返回值：成功返回0， 失败返回-1

2. **int chmod(const char *filename, int mode_t);**

​	—— 作用：修改文件的权限

​         参数：

​        \- pathname: 需要修改的文件的路径

​        \- mode:需要修改的权限值，八进制的数

​          返回值：成功返回0，失败返回-1

3. **int** **chown(const char *path, uid_t owner, gid_t group);**

   —— 作用：修改文件的所有者或所在组

   `vim /etc/passwd`——显示所有的用户和id、组id

   `vim /etc/group`——查看当前系统所有组和id

   `useradd xx`——创建xx用户

   `id xx`——查看xxid

4. **int truncate(const char path, off_t length);**

   作用：缩减或者扩展文件的尺寸至指定的大小

   ​    参数：

   ​      \- path: 需要修改的文件的路径

   ​      \- length: 需要最终文件变成的大小

   ​    返回值：

   ​      成功返回0， 失败返回-1

   ——`touch xx.xx` 创建xx.x文件

   ——`vim xx.x`进入xx.x文件

### 6.9 目录操作函数

```c
int mkdir(const char *pathname, mode_t mode);
int rmdir(const char *pathname);
int rename(const char *oldpath, const char *newpath);
int chdir(const char *path);
char *getcwd(char *buf, size_t size);
```

1. **int mkdir(const char *pathname, mode_t mode);**

​	`man 2 xxx`——查看Linux系统函数xx

​	—— 作用：创建一个目录

​    	参数：

​     	 pathname: 创建的目录的路径

​      	mode: 权限，八进制的数

​    	返回值：

​      	成功返回0， 失败返回-1

```c
#include <sys/stat.h>
#include <sys/types.h>
#include <stdio.h>

int main() {

    int ret = mkdir("aaa", 0777);

    if(ret == -1) {
        perror("mkdir");
        return -1;
    }

    return 0;
}
```

结果：创建了aaa目录

```shell
nowcoder@nowcoder:~/Linux/lesson14$ gcc mkdir.c -o mkdir
nowcoder@nowcoder:~/Linux/lesson14$ ./mkdir
nowcoder@nowcoder:~/Linux/lesson14$ ll
总用量 36
drwxrwxr-x 3 nowcoder nowcoder 4096 4月  22 13:31 ./
drwxr-xr-x 9 nowcoder nowcoder 4096 4月  22 11:35 ../
drwxrwxr-x 2 nowcoder nowcoder 4096 4月  22 13:31 aaa/
-rw-rw-r-- 1 nowcoder nowcoder 1369 4月  22 11:35 chdir.c
-rwxrwxr-x 1 nowcoder nowcoder 8344 4月  22 13:31 mkdir*
-rw-rw-r-- 1 nowcoder nowcoder  519 4月  22 11:35 mkdir.c
-rw-rw-r-- 1 nowcoder nowcoder  246 4月  22 11:35 rename.c
```

2. **int rmdir(const char *pathname);**

   ——作用：删除空目录

3. **int rename(const char *oldpath, const char *newpath);**

   ——作用：重命名

4. **int chdir(const char *path);**

   ——作用：修改进程的工作目录

   比如在/home/nowcoder 启动了一个可执行程序a.out, 进程的工作目录 /home/nowcoder

   ——参数：

   ​      path : 需要修改的工作目录

5. **char *getcwd(char *buf, size_t size);**

​	——作用：获取当前的工作路径

​	参数：

​      	\- buf : 存储的路径，指向的是一个数组（传出参数）

​     	 \- size: 数组的大小

​        返回值：

​        	 返回的指向的一块内存，这个数据就是第一个参数

```C
#include <unistd.h>
#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>

int main() {

    // 获取当前的工作目录
    char buf[128];
    getcwd(buf, sizeof(buf));
    printf("当前的工作目录是：%s\n", buf);

    // 修改工作目录
    int ret = chdir("/home/nowcoder/Linux/lesson13");
    if(ret == -1) {
        perror("chdir");
        return -1;
    } 

    // 创建一个新的文件,在当前工作目录下创建
    int fd = open("chdir.txt", O_CREAT | O_RDWR, 0664);
    if(fd == -1) {
        perror("open");
        return -1;
    }

    close(fd);

    // 获取当前的工作目录
    char buf1[128];
    getcwd(buf1, sizeof(buf1));
    printf("当前的工作目录是：%s\n", buf1);
    
    return 0;
}
```



### 6.10 目录遍历函数

```C
DIR *opendir(const char *name);			//打开目录
struct dirent *readdir(DIR *dirp);		//读取目录
int closedir(DIR *dirp);				//关闭目录
```

shell终端输入`man 3 xx`——查看标准C库函数

* dirent结构体和d_type

![image-20240422203357809](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240422203357809.png)

```c
/*
    // 打开一个目录
    #include <sys/types.h>
    #include <dirent.h>
    DIR *opendir(const char *name);
        参数：
            - name: 需要打开的目录的名称
        返回值：
            DIR * 类型，理解为目录流
            错误返回NULL


    // 读取目录中的数据,每调用一次reader就在目录流中往后读取一个目录
    #include <dirent.h>
    struct dirent *readdir(DIR *dirp);
        - 参数：dirp是opendir返回的结果
        - 返回值：
            struct dirent，代表读取到的文件的信息
            读取到了末尾或者失败了，返回NULL

    // 关闭目录
    #include <sys/types.h>
    #include <dirent.h>
    int closedir(DIR *dirp);

*/
#include <sys/types.h>
#include <dirent.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int getFileNum(const char * path);
// 读取某个目录下所有的普通文件的个数
int main(int argc, char * argv[]) {
    if(argc < 2) {
        printf("%s path\n", argv[0]);
        return -1;
    }
    int num = getFileNum(argv[1]);
    printf("普通文件的个数为：%d\n", num);
    return 0;
}
// 用于获取目录下所有普通文件的个数
int getFileNum(const char * path) {
    // 1.打开目录
    DIR * dir = opendir(path);
    if(dir == NULL) {
        perror("opendir");
        exit(0);
    }
    struct dirent *ptr;

    // 记录普通文件的个数
    int total = 0;

    while((ptr = readdir(dir)) != NULL) {
        // 获取名称
        char * dname = ptr->d_name;
        // 忽略掉. 和..
        if(strcmp(dname, ".") == 0 || strcmp(dname, "..") == 0) {
            continue;
        }
        // 判断是否是普通文件还是目录
        if(ptr->d_type == DT_DIR) {
            // 目录,需要继续读取这个目录
            char newpath[256];
            sprintf(newpath, "%s/%s", path, dname);
            total += getFileNum(newpath);
        }
        if(ptr->d_type == DT_REG) {
            // 普通文件
            total++;
        }
    }
    // 关闭目录
    closedir(dir);
    return total;
}
```

### 6.11 dup、dup2函数

```C
int dup(int oldfd);
复制文件描述符
int dup2(int oldfd,int newfd);
重定向文件描述符
```

1. \#include <unistd.h>

   int dup(int oldfd);

​    	作用：复制一个新的文件描述符,指向同一个文件

​    	fd=3, int fd1 = dup(fd),

​    	fd指向的是a.txt, fd1也是指向a.txt

​    	从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符

```c
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>

int main() {

    int fd = open("a.txt", O_RDWR | O_CREAT, 0664);

    int fd1 = dup(fd);

    if(fd1 == -1) {
        perror("dup");
        return -1;
    }

    printf("fd : %d , fd1 : %d\n", fd, fd1);

    close(fd);

    char * str = "hello,world";
    int ret = write(fd1, str, strlen(str));
    if(ret == -1) {
        perror("write");
        return -1;
    }

    close(fd1);

    return 0;
}
```

2. \#include <unistd.h>

     int dup2(int oldfd, int newfd);

   ​    作用：重定向文件描述符

   ​    oldfd 指向 a.txt, newfd 指向 b.txt

   ​    调用函数成功后：newfd 和 b.txt 做close, newfd 指向了 a.txt

   ​    oldfd 必须是一个有效的文件描述符

   ​    oldfd和newfd值相同，相当于什么都没有做

   ​    返回值是：return the  new  file  descriptor

   */

   ```C
   #include <unistd.h>
   #include <stdio.h>
   #include <string.h>
   #include <sys/stat.h>
   #include <sys/types.h>
   #include <fcntl.h>
   
   int main() {
   
       int fd = open("1.txt", O_RDWR | O_CREAT, 0664);
       if(fd == -1) {
           perror("open");
           return -1;
       }
   
       int fd1 = open("2.txt", O_RDWR | O_CREAT, 0664);
       if(fd1 == -1) {
           perror("open");
           return -1;
       }
   
       printf("fd : %d, fd1 : %d\n", fd, fd1);
   
       int fd2 = dup2(fd, fd1);//fd2==fd1
       if(fd2 == -1) {
           perror("dup2");
           return -1;
       }
   
       // 通过fd1去写数据，实际操作的是1.txt，而不是2.txt
       char * str = "hello, dup2";
       int len = write(fd1, str, strlen(str));
   
       if(len == -1) {
           perror("write");
           return -1;
       }
   
       printf("fd : %d, fd1 : %d, fd2 : %d\n", fd, fd1, fd2);
   
       close(fd);
       close(fd1);
   
       return 0;
   }
   ```


### 6.12  fcntl函数

1. **int fcntl ( int fd, int cmd, .../*arg */ );**
   	复制文件描述符
   	设置/获取文件的状态标志

```C
/*

    #include <unistd.h>
    #include <fcntl.h>

    int fcntl(int fd, int cmd, ...);
    参数：
        fd : 表示需要操作的文件描述符
        cmd: 表示对文件描述符进行如何操作
            - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值）
                int ret = fcntl(fd, F_DUPFD);

            - F_GETFL : 获取指定的文件描述符文件状态flag
              获取的flag和我们通过open函数传递的flag是一个东西。

            - F_SETFL : 设置文件描述符文件状态flag
              必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改
              可选性：O_APPEND, O)NONBLOCK
                O_APPEND 表示追加数据
                NONBLOK 设置成非阻塞
        
        阻塞和非阻塞：描述的是函数调用的行为。
*/

#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>

int main() {

    // 1.复制文件描述符
    // int fd = open("1.txt", O_RDONLY);
    // int ret = fcntl(fd, F_DUPFD);

    // 2.修改或者获取文件状态flag
    int fd = open("1.txt", O_RDWR);
    if(fd == -1) {
        perror("open");
        return -1;
    }

    // 获取文件描述符状态flag
    int flag = fcntl(fd, F_GETFL);
    if(flag == -1) {
        perror("fcntl");
        return -1;
    }
    flag |= O_APPEND;   // flag = flag 按位或 O_APPEND

    // 修改文件描述符状态的flag，给flag加入O_APPEND这个标记
    int ret = fcntl(fd, F_SETFL, flag);
    if(ret == -1) {
        perror("fcntl");
        return -1;
    }

    char * str = "nihao";
    write(fd, str, strlen(str));

    close(fd);

    return 0;
} 
```

***



## 7. 进程

### 7.1进程概述

####  7.1.1 程序与进程

* 程序占用磁盘资源，但不占用CPU和内存，进程占用CPU和内存，但不占用磁盘。程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程:
  * **二进制格式标识**:每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。(ELF可执行连接格式)
  * **机器语言指令:**对程序算法进行编码。
  * **程序入口地址:**标识程序开始执行时的起始指令位置。
  * **数据:**程序文件包含的变量初始值和程序使用的字面量值(比如字符串)
  * **符号表及重定位表:**描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析(动态链接)
  * **共享库和动态链接信息:**程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名
  * **其他信息:**程序文件还包含许多其他信息，用以描述如何创建进程

* 进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。
*  可以用一个程序来创建多个进程，进程是由内核定义的<font color='red'>抽象实体</font>，并为该实体分配用以执行程序的各项系统资源。从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中<font color='blue'>用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。</font>记录在内核数据结构中的信息包括许多与进程相关的标识号(IDs)、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。

#### 7.1.2 单道、多道程序设计

* 单道程序，即在计算机内存中只允许一个的程序运行。
* 多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，<font color='red'>**相互穿插运行**</font>，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态，这些程序共享计算机系统资源。**<font color='red'>引入多道程序设计技术的根本目的是为了提高 CPU 的利用率。</font>**
* 对于一个单CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽、然都已经开始运行，但<font color='red'>就微观而言，任意时刻，CPU上运行的程序只有一个。</font>
* 在多道程序设计模型中，多个进程轮流使用CPU。而当下常见CPU为纳秒级，1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行

#### 7.1.3 时间片

* 时间片(timeslice)又称为“量子(quantum)"或“处理器片(processor slice)是<font color='red'>操作系统分配给每个正在运行的进程微观上的一段CPU时间。</font>事实上，虽然一台计算机通常可能有多个 CPU，但是同一个CPU 永远不可能真正地同时运行多个任务。在只考虑一个 CPU 的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行由于时间片通常很短(在inux上为5ms-800ms)，用户不会感觉到。

* <font color='red'>时间片由操作系统内核的调度程序分配给每个进程。</font>首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。

#### 7.1.4 并行和并发

* **并行(paralle1):**指在同一时刻，有多条指令在多个处理器上同时执行。
* **并发(concurrency):**指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的只是把时间分成若干段，使多个进程快速交替的执行。

 ![image-20240423204853427](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240423204853427.png)

* 并发是两个队列交替使用一台咖啡机。
  并行是两个队列同时使用两台咖啡机。

  ![image-20240423205118283](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240423205118283.png)

#### 7.1.5 进程控制块PCB/进程描述符表

* 为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个 PCB(Processing Control Block)进程控制块，维护进程相关的信息，Linux内核的进程控制块是 **task struct 结构体**
* 在/usr/src/linux-headers-xxx/include/linux/sched.h 文件中可以看 struct task struct 结构体定义。其内部成员有很多，我们只需要掌握以部分即可:
  * 进程id:系统中每个进程有唯一的id，用pidt类型表示，其实就是一个非负整数
  * 进程的状态:有就绪、运行、挂起、停止等状态
  * 进程切换时需要保存和恢复的一些CPU寄存器
  * 描述虚拟地址空间的信息
  * 描述控制终端的信息
  * 当前工作目录(Current Working Directory)
  * umask 掩码
  * 文件描述符表，包含很多指向 file 结构体的指针
  * 和信号相关的信息
  * 用户 id 和组 id
  * 会话(Session)和进程组
  * 进程可以使用的资源上限(Resource Limit)

### 7.2 进程状态转换

#### 7.2.1 进程的状态

* 进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换在三态模型中，进程状态分为三个基本状态，即就绪态，运行态，阻塞态。在五态模型中，进程分为新建态、就绪态，运行态，阻塞态，终止态。
  * 运行态:进程占有处理器正在运行
  * 就绪态:进程具备运行条件，等待系统分配处理器以便运行。当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列
  * 阻塞态:又称为等待(wait)态或睡眠(sleep)态，指进程不具备运行条件，正在等待某个事件的完成

![image-20240423212620638](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240423212620638.png)

 ![image-20240423214654291](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240423214654291.png)

#### 7.2.2 进程相关命令

* **查看进程**
  `ps aux/ajx`
  a: 显示终端上的所有进程，包括其他用户的进程
  u: 显示进程的详细信息
  x: 显示没有控制终端的进程
   j: 列出与作业控制相关的信息

​	`tty`——查看当前进程对应的终端

```
*STAT参数意义
	D			不可中断 Uninterruptible(usually IO)
	R			正在运行，或在队列中的进程
	S(大写)	   处于休眠状态
	T			停止或被追踪
	Z			僵尸进程
	W			进入内存交换(从内核2.6开始无效)
	X			死掉的进程
	<			高优先级
	N			低优先级
	s			包含子进程
	+			位于前台的进程组
```

* **实时显示进程动态**
  	`top`
  	可以在使用 top 命令时加上 -d 来指定显示信息更新的时间	间隔，在 top 命令执行后，可以按以下按键对显示的结果	进行排序:
  		M		根据内存使用量排序
  		P  		根据CPU 占有率排序
  		T		  根据进程运行时间长短排序
  		U		 根据用户名来筛选进程
  		K		  输入指定的 PID 杀死进程
  * **杀死进程**
    1. kill [-signal]pid
    2. kill -l 列出所有信号
    3. kill-SIGKILL 进程ID         强制杀死进程
    4. kill -9 进程ID                     强制杀死进程
    5. killall name 根据进程名杀死进程

`./xx.xxx(可执行程序) &`——在后台运行程序

#### 7.2.3进程号和相关函数

* 每个进程都由进程号来标识，其类型为pidt(整型)，进程号的范围:0~32767进程号总是唯一的，但可以重用。当一个进程终止后，其进程号就可以再次使用。
* 任何进程(除 init 进程)都是由另一个进程创建，该进程称为被创建进程的父进程对应的进程号称为父进程号(PPID)
* 进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号(PGID)。默认情况下，当前的进程号会当做当前的进程组号
* 进程号和进程组相关函数:
  * pid t getpid(void);
  * pid t getppid(void);
  * pid t getpgid(pid t pid);

### 7.3 进程创建

系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成G进程树结构模型。

```c
#include <sys/types.h>
#include <unistd.h>
 pid_t fork(void);
```

返回值:
	成功:子进程中返回 0，父进程中返回子进程ID

​	失败:返回 -1

失败的两个主要原因:

1. 当前系统的进程数已经达到了系统规定的上限，这时errno的值被设置为 EAGAIN
2. 系统内存不足，这时errno 的值被设置为NOMEM

```c
/*
    #include <sys/types.h>
    #include <unistd.h>

    pid_t fork(void);
        函数的作用：用于创建子进程。
        返回值：
            fork()的返回值会返回两次。一次是在父进程中，一次是在子进程中。
            在父进程中返回创建的子进程的ID,
            在子进程中返回0
            如何区分父进程和子进程：通过fork的返回值。
            在父进程中返回-1，表示创建子进程失败，并且设置errno

        父子进程之间的关系：
        区别：
            1.fork()函数的返回值不同
                父进程中: >0 返回的子进程的ID
                子进程中: =0
            2.pcb中的一些数据
                当前的进程的id pid
                当前的进程的父进程的id ppid
                信号集

        共同点：
            某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作
                - 用户区的数据
                - 文件描述符表
        
        父子进程对变量是不是共享的？
            - 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。
            - 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。
        
*/

#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>

int main() {

    int num = 10;

    // 创建子进程
    pid_t pid = fork();

    // 判断是父进程还是子进程
    if(pid > 0) {
        // printf("pid : %d\n", pid);
        // 如果大于0，返回的是创建的子进程的进程号，当前是父进程
        printf("i am parent process, pid : %d, ppid : %d\n", getpid(), getppid());

        printf("parent num : %d\n", num);
        num += 10;
        printf("parent num += 10 : %d\n", num);


    } else if(pid == 0) {
        // 当前是子进程
        printf("i am child process, pid : %d, ppid : %d\n", getpid(),getppid());
       
        printf("child num : %d\n", num);
        num += 100;
        printf("child num += 100 : %d\n", num);
    }

    // for循环
    for(int i = 0; i < 3; i++) {
        printf("i : %d , pid : %d\n", i , getpid());
        sleep(1);
    }

    return 0;
}

/*
实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。
写时拷贝是一种可以推迟甚至避免拷贝数据的技术。
内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。
只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。
也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。
注意：fork之后父子进程共享文件，
fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。
*/
```

### 7.4 父子进程虚拟地址空间情况

![image-20240424124551272](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240424124551272.png)

![image-20240424133741867](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240424133741867.png)

 ```C
 //程序运行后的结果，父子进程中的num变量互不影响
 nowcoder@nowcoder:~/Linux/leeson18$ gcc fork.c -o fork
 nowcoder@nowcoder:~/Linux/leeson18$ ./fork
 i am parent process, pid : 61840, ppid : 61802
 parent num : 10
 parent num += 10 : 20
 i : 0 , pid : 61840
 i am child process, pid : 61841, ppid : 61840
 child num : 10
 child num += 100 : 110
 i : 0 , pid : 61841
 i : 1 , pid : 61841
 i : 1 , pid : 61840
 i : 2 , pid : 61841
 i : 2 , pid : 61840
 ```

### 7.5 父子进程关系及GBD多进程调试

#### 7.5.1 GBD多进程调试

使用GDB 调试的时候，GDB 默认只能跟踪一个进程，可以在fork 函数调用之前，通过指令设置 GDB 调试工具跟踪父进程或者是跟踪子进程，**默认跟踪父进程**。
<font color='orange'>设置调试父进程或者子进程</font>:`set follow-fork-mode [parent(默认)Ichild]`

<font color='orange'>设置调试模式</font>:set detach-on-fork[on | off]`

<font color='orange'>查看调试进程：</font>`show follow-fork-mode`

```c
(gdb) show follow-fork-mode
Debugger response to a program call of fork or vfork is "parent".
(gdb) set follow-fork-mode child
(gdb) show follow-fork-mode
Debugger response to a program call of fork or vfork is "child".
```



默认为 on，表示调试当前进程的时候，其它的进程继续运行，如果为f，调试当前进程的时候，其它进程被 GDB 挂起。
<font color='orange'>查看调试的进程:</font>` info inferiors`

<font color='orange'>切换当前调试的进程:</font>`inferior id`

<font color='orange'>使进程脱离 GDB调试:</font>`detach inferiors id`

`gdb 文件名`进入gdb调试

`gdb l`查看代码

`b 行数` 在某行打断点

`i b`查看断点信息

`r`运行程序

`n`是单步调试

`c`执行完剩下的代码

安装ubuntu16

### 7.6 exec函数族

——像C++中的函数重载，是一系列功能相同或相似的函数

#### 7.6.1exec函数族介绍

* 函数族的作用是<font color='blue'>根据指定的文件名找到可执行文件</font>，并用它来取代调用进程的exeC内容，换句话说，就是在调用进程内部执行一个可执行文件。
* exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样颇有些神似“三十六计"中的“金蝉脱壳"。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回-1，从原程序的调用点接着往下执行。

#### 7.6.2 函数族图解

内核区维护着当前进程的一些信息，比如id、状态、

![image-20240425101754446](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240425101754446.png)

#### 7.6.4 exec函数族

```C
int execl(const char *path,const char *arg,.../* (char *) NULL */);

int execlp(const char *file,const char *arg,.../* (char *)NULL */);

int execle(const char *path,const char *arg,.../*,(char *)NULL, char* const envp[] */);
int execv(const char *path,char *const argv[]);
int execvp(const char *file,char *const argv[]);
int execvpe(const char *file,char *const argv[], char *const envp[]);
int execve(const char *filename,char *const argv[],char *const envp[]);

1 (list)		参数地址列表，以空指针结尾
v(vector)		存有各参数地址的指针数组的地址
P(path)			按 PATH 环境变量指定的目录搜索可执行文件
e(environment)	存有环境变量字符串地址的指针数组的地址e
```

`which 程序名`——查看程序所在目录

```C
/* execl函数 
    #include <unistd.h>
    int execl(const char *path, const char *arg, ...);
        - 参数：
            - path:需要指定的执行的文件的路径或者名称
                a.out /home/nowcoder/a.out 推荐使用绝对路径
                ./a.out hello world

            - arg:是执行可执行文件所需要的参数列表
                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称
                从第二个参数开始往后，就是程序执行所需要的的参数列表。
                参数最后需要以NULL结束（哨兵）

        - 返回值：
            只有当调用失败，才会有返回值，返回-1，并且设置errno
            如果调用成功，没有返回值。
*/
#include <unistd.h>
#include <stdio.h>

#include <fcntl.h>

int main() {
    // 创建一个子进程，在子进程中执行exec函数族中的函数
    pid_t pid = fork();

    if(pid > 0) {
        // 父进程
        printf("i am parent process, pid : %d\n",getpid());
        sleep(1);
    }else if(pid == 0) {
        // 子进程
        execl("hello","hello",NULL);

        //execl("/bin/ps", "ps", "aux", NULL);
        //perror("execl");
        printf("i am child process, pid : %d\n", getpid());

    }

    for(int i = 0; i < 3; i++) {
        printf("i = %d, pid = %d\n", i, getpid());
    }
    return 0;
}
```

```C
//结果
nowcoder@nowcoder:~/Linux/lesson19$ gcc execl.c -o execl
nowcoder@nowcoder:~/Linux/lesson19$ ./execl
i am parent process, pid : 68644
hello, world
i = 0, pid = 68644
i = 1, pid = 68644
i = 2, pid = 68644
```

```C
/*  
    #include <unistd.h>
    int execlp(const char *file, const char *arg, ... );
        - 会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行不成功。
        - 参数：
            - file:需要执行的可执行文件的文件名
                a.out
                ps

            - arg:是执行可执行文件所需要的参数列表
                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称
                从第二个参数开始往后，就是程序执行所需要的的参数列表。
                参数最后需要以NULL结束（哨兵）

        - 返回值：
            只有当调用失败，才会有返回值，返回-1，并且设置errno
            如果调用成功，没有返回值。


        int execv(const char *path, char *const argv[]);
        argv是需要的参数的一个字符串数组
        char * argv[] = {"ps", "aux", NULL};
        execv("/bin/ps", argv);

        int execve(const char *filename, char *const argv[], char *const envp[]);
        char * envp[] = {"/home/nowcoder", "/home/bbb", "/home/aaa"};


*/
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>
int main() {


    // 创建一个子进程，在子进程中执行exec函数族中的函数
    pid_t pid = fork();

    if(pid > 0) {
        // 父进程
        printf("i am parent process, pid : %d\n",getpid());
        sleep(1);
    }else if(pid == 0) {
        // 子进程
        execlp("ps", "ps", "aux", NULL);

        printf("i am child process, pid : %d\n", getpid());

    }

    for(int i = 0; i < 3; i++) {
        printf("i = %d, pid = %d\n", i, getpid());
    }


    return 0;
}
```

### 7.7 进程控制

#### 7.7.1进程退出exit

![image-20240425124936108](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240425124936108.png)

`status`是进程退出时的一个状态信息。父进程回收子进程资源的时候可以获取到。

```C
/*
    #include <stdlib.h>
    void exit(int status);

    #include <unistd.h>
    void _exit(int status);

    status参数：是进程退出时的一个状态信息。父进程回收子进程资源的时候可以获取到。
*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {

    printf("hello\n");
    printf("world");

    // exit(0);
    _exit(0);
    
    return 0;
}
```

#### 7.7.2孤儿进程

* 父进程运行结束，但子进程还在运行(未运行结束)，这样的子进程就称为**孤儿进程**(Orphan Process)
* 每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而init进程会循环地 wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。
* 因此孤儿进程并不会有什么危害。

![image-20240425133450437](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240425133450437.png)

#### 7.7.3僵尸进程

* 每个进程结束之后，都会释放自己地址空间中的用户区数据，内核区的PCB没有办法自己释放掉，需要父进程去释放。
* 进程终止时，父进程尚未回收，子进程残留资源(PCB)存放于内核中，变成僵尸(Zombie)进程。
* 僵尸进程不能被 kill -9 杀死。
* 这样就会导致一个问题，如果父进程不调用wait()或 waitpid()的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。

治理僵尸进程：

​	杀死父进程 `kill -9 进程号`

### 7.8 wait函数

#### 7.8.1进程回收

* 在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息包括进程号、退出状态、运行时间等)
* 父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。
* wait()和 waitpid()函数的功能一样，区别在于，wait()函数会阻塞waitpid()可以设置不阻塞，waitpid()还可以指定等待哪个子进程结束
* 注意:一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。

#### 7.8.2退出信息相关函数

```C
WIFEXITED(status)非0，进程正常退出
WEXITSTATUS(statu)如果上宏为真，获取进程退出的状态(exit的参数)

WIFSIGNALED(status)非0，进程异常终止
WTERMSIG(status)如果上宏为真，获取使进程终止的信号编号

WIFSTOPPED(status)非0，进程处于暂停状态
WSTOPSIG(status)如果上宏为真，获取使进程暂停的信号的编号
WIFCONTINUED(status)非0，进程暂停后已经继续运行
```

```c
/*
    #include <sys/types.h>
    #include <sys/wait.h>
    pid_t wait(int *wstatus);
        功能：等待任意一个子进程结束，如果任意一个子进程结束了，次函数会回收子进程的资源。
        参数：int *wstatus
            进程退出时的状态信息，传入的是一个int类型的地址，传出参数。
        返回值：
            - 成功：返回被回收的子进程的id
            - 失败：-1 (所有的子进程都结束，调用函数失败)

    调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）
    如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回-1.

*/
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>


int main() {

    // 有一个父进程，创建5个子进程（兄弟）
    pid_t pid;

    // 创建5个子进程
    for(int i = 0; i < 5; i++) {
        pid = fork();
        if(pid == 0) {//防止产生孙子进程
            break;
        }
    }

    if(pid > 0) {
        // 父进程
        while(1) {
            printf("parent, pid = %d\n", getpid());

            // int ret = wait(NULL);
            int st;
            int ret = wait(&st);

            if(ret == -1) {			//没有子进程回收就break
                break;
            }

            if(WIFEXITED(st)) {
                // 是不是正常退出
                printf("退出的状态码：%d\n", WEXITSTATUS(st));
            }
            if(WIFSIGNALED(st)) {
                // 是不是异常终止
                printf("被哪个信号干掉了：%d\n", WTERMSIG(st));
            }

            printf("child die, pid = %d\n", ret);

            sleep(1);
        }

    } else if (pid == 0){
        // 子进程
         while(1) {
            printf("child, pid = %d\n",getpid());    
            sleep(1);       
         }

        exit(0);
    }

    return 0; // exit(0)
}
```

### 7.9 waitpid函数

```c
#include <sys/types.h>
#include <sys/wait.h>
    pid_t waitpid(pid_t pid, int *wstatus, int options);
        功能：回收指定进程号的子进程，可以设置是否阻塞。
        参数：
            - pid:
                pid > 0 : 某个子进程的pid
                pid = 0 : 回收当前进程组的所有子进程    
                pid = -1 : 回收所有的子进程，相当于 wait()  （最常用）
                pid < -1 : 某个进程组的组id的绝对值，回收指定进程组中的子进程
            - options：设置阻塞或者非阻塞
                0 : 阻塞
                WNOHANG : 非阻塞
            - 返回值：
                > 0 : 返回子进程的id
                = 0 : options=WNOHANG, 表示还有子进程或者
                = -1 ：错误，或者没有子进程了
```

```C
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main() {

    // 有一个父进程，创建5个子进程（兄弟）
    pid_t pid;

    // 创建5个子进程
    for(int i = 0; i < 5; i++) {
        pid = fork();
        if(pid == 0) {
            break;
        }
    }

    if(pid > 0) {
        // 父进程
        while(1) {
            printf("parent, pid = %d\n", getpid());
            sleep(1);

            int st;
            // int ret = waitpid(-1, &st, 0);
            int ret = waitpid(-1, &st, WNOHANG);

            if(ret == -1) {
                break;
            } else if(ret == 0) {
                // 说明还有子进程存在
                continue;
            } else if(ret > 0) {

                if(WIFEXITED(st)) {
                    // 是不是正常退出
                    printf("退出的状态码：%d\n", WEXITSTATUS(st));
                }
                if(WIFSIGNALED(st)) {
                    // 是不是异常终止
                    printf("被哪个信号干掉了：%d\n", WTERMSIG(st));
                }

                printf("child die, pid = %d\n", ret);
            }
           
        }

    } else if (pid == 0){
        // 子进程
         while(1) {
            printf("child, pid = %d\n",getpid());    
            sleep(1);       
         }
        exit(0);
    }

    return 0; 
}
```

### 7.10 进程间通信（进程与进程之间收发数据的过程）

1. 进程间通信的方式有哪几种
2. 进程间通信某个方式的具体原理

* 进程是一个独立的资源分配单元，不同进程(这里所说的进程通常指的是用户进程)之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。
* 但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信(IPC:Inter Processes Communication)。
* 进程间通信的目的:
  * 数据传输:一个进程需要将它的数据发送给另一个进程。
  * 通知事件:一个进程需要向另一个或一组进程发送消息，通知它(它们)发生了某种事件(如进程终止时要通知父进程)
  * 资源共享:多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。
  * 进程控制:有些进程希望完全控制另一个进程的执行(如Debug进程)，此时
  * 控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变
