---
title: 操作系统
date: 2024-06-24 11:15:33
tags: 操作系统
cover: /img/OS.jpg
---

CPU中有一系列的寄存器来存储数据，

* 通用寄存器
  * EAX:累加器
  * EBX:基址寄存器
  * ECX:计数器
  * EDX:数据寄存器
  * ESI:源地址指针寄存器
  * EDI:目的地址指针寄存器
  * EBP:基址指针寄存器
  * ESP:堆栈指针寄存器
* 段寄存器，主要用来寻址
  * CS:代码段(Code Segment)
  * DS:数据段(Data Segment)
  * ES:附加数据段(Extra Segment)
  * SS:堆栈段(Stack Segment)
  * FS:附加段
  * GS:附加段
* 指令指针寄存器4
  * 指令寄存器和标志寄存器
    * EIP:指令寄存器
      	EIP的低16位就是8086的IP，它存储的是下一条要执行指令的内存地址，在分段地址转换中，表示指令的段内偏移地址。
    * EFLAGS:标志寄存器
              IF(Interrupt Flag):中断允许标志位,由CLI，STI两条指令来控制;设置IF 使CPU可识别外部(可屏蔽)中断请求。复位IF 则禁止中断。IF 对不可屏蔽外部中断和故障中断的识别没有任何作用。
              CF,PF,ZF,...

### 了解x86内存构架

* 地址是访问内存空间的索引。
* 80386是32位的处理器，即可以寻址的物理内存地址空间为2^32=4G字节
* 物理内存地址空间是处理器提交到总线上用于访问计算机系统中的内存和外设的最终地址。一个计算机系统中只有一个物理地址空间
* 线性地址空间是在操作系统的虚存管理之下每个运行的应用程序能访问的地址空间。**每个运行的应用程序都认为自己独享整个计算机系统的地址空间**，这样可让多个运行的应用程序之间相互隔离。
* 逻辑地址空间是应用程序直接使用的地址空间。
  * 段机制启动、页机制未启动:逻辑地址->段机制处理->线性地址=物理地址
  * 段机制和页机制都启动:逻辑地址->段机制处理->线性地址->页机制处理->物理地址逻辑地址通过段机制的映射能转变成线性地址

## A启动、中断、异常和系统调用

![image-20240702132318999](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240702132318999.png)

* 系统调用(来源于应用程序)（同步或异步）
  * 应用程序主动向操作系统发出服务请求
* 异常(来源于不良的应用程序)（同步）
  * 非法指令或者其他坏的处理状态(如:内存出错)
* 中断(来源于外设)（异步）
  * 来自不同的硬件设备的计时器和网络的中断

## **B内存分层体系**

### 计算机体系结构

![img](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/702b81a12fd928d143e37eaf2bd89317.png)

### 内存分层体系

![image-20220519132737567](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/118c02d62c8f895a5820b030f30b48cf.png)

* CPU可以访问的内存包括两大类 : 寄存器 / cache（L1缓存 / L2缓存）
* 主存（物理内存）/ 磁盘（虚拟内存）主存是在运行程序时所需要保存的数据空间，而磁盘是用于持久化数据保存的数据空间。

### 操作系统的内存管理&地址空间、地址生成

#### 目标

- 抽象：逻辑地址空间
- 保护：独立地址空间
- 共享：访问相同内存
- 虚拟：更多的地址空间

![image-20220519133102329](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/c73333cfe3083fb46251654026f9dbe9.png)

- 物理地址空间：主存和硬盘
- 逻辑地址空间：运行的程序

### 内存分配

![image-20220523164331726](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/6bab2c97eca46877a4c12a56d3fa1ab3.png)

#### 连续内存分配

##### **内存碎片问题**

![image-20240703150359391](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240703150359391.png)

##### **分区的动态分配**

1. | **分配方式** | **第一适配分配**                                             | **最优适配分配**                                             | **最差适配分配**                                             |
   | ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | 原理&实现    | 按地址排序的空闲块列表 <br />分配需要寻找一个合适的分区 <br />重分配需要检查是否可以合并相邻空闲分区 | 按尺寸排序的空闲块列表 <br />分配需要寻找一个合适的分区 <br />重分配需要检查是否可以合并相邻空闲分区 | 按尺寸排序的空闲块列表 <br />分配差距最大的分区<br />重分配需要检查是否可以合并相邻空闲分区 |
   | 优势         | 简单 / 易于产生更大空闲块                                    | 比较简单 / 大部分分配是小尺寸时高效                          | 分配很快 / 大部分分配是中尺寸时高效                          |
   | 劣势         | 产生外部碎片 / 不确定性                                      | 产生外部碎片 / 重分配慢 / 产生很多没用的微小碎片             | 产生外部碎片 / 重分配慢 / 易于破碎大的空闲块以致大分区无法被分配 |

```
三种分配方式并无优劣之分，因为我们无法判断内存请求的大小。
```

##### 压缩式与交换式碎片整理

##### 压缩式碎片整理

> **紧凑（compaction）**

- 重置程序以合并孔洞（碎片）

- 要求所有程序是 动态可重置的

- 问题 :

  ➢ 何时重置？（在程序处于等待状态时才可以重置）

  ➢ 开销（内存拷贝：重定位）

##### 交换式碎片整理

> **分区对换（Swapping in/out）**

- 运行程序需要更多的内存时，抢占等待的程序并回收它们的内存，以增大可用内存空间

#### 非连续内存分配

> 关键在于如何建立虚拟地址和物理地址之间的转换
>
> >软件方案
> >
> >硬件方案

* 两种硬件方案

##### 分段

* > 段表由操作系统建立

  ##### ![image-20240703205007433](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240703205007433.png)

##### 分页

 		>划分物理内存至固定大小的帧

​		>划分逻辑地址空间至相同大小的页

​		**帧代表物理页，page代表逻辑页**

>页帧是指物理内存的组织和布局，代表物理内存的地址，第一个是页帧号，第二个是帧内偏移；

![image-20240703211103475](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240703211103475.png)

> 逻辑页
>
> 页表：记录页号所对应的页帧；

![image-20240703212643349](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240703212643349.png)

![image-20240703215916038](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240703215916038.png)

![image-20240703220023647](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240703220023647.png)

##### 页表

> 页表结构

![image-20240703220348648](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240703220348648.png)

![image-20240703222042140](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240703222042140.png)

**分页机制的性能问题**

解决方式：

> 缓存Caching
>
> 间接访问（inderection）

![image-20240704095234271](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240704095234271.png)

分级页表

![image-20240704095400810](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240704095400810.png)

![image-20240704095538580](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240704095538580.png)

**反向页表**

◆大地址空间问题
   有大地址空间(64-bits)，前向映射页表变得繁琐

> 比如:5 级页表.

◆不是让页表与逻辑地址空间的大小相对应,而是**让页表与物理地址空间的大小相对应**.

>逻辑(虚拟)地址空间增长速度快于物理地址空间

**基于页寄存器Page Register的方案**

![image-20240704102257046](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240704102257046.png)

**基于关联内存的方案**

![image-20240704103849530](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240704103849530.png)

**基于哈希查找的方案**

> 哈希函数的输入就是页号以及当前程序的id（PID），输出就是页帧号；

![image-20240704105804689](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240704105804689.png)

![image-20220520202205602](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/ce2cba34b4cf7dc05bd4b1bccba1233e.png)

## C虚拟内存管理技术

![image-20240704112106046](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240704112106046.png)

**在计算机系统中，尤其是在多道程序运行的环境下，可能会出现内存不够用的情况，怎么办？**

* 如果是程序太大，超过了内存的容量，可以采用手动的覆盖（overlay）技术，只把需要的指令和数据保存在内存当中；

* 如果是程序太多，超过了内存的容量，可以采用自动的交换（swapping）技术，把暂时不能执行的程序送到外存中；

* 如果想要在有限容量的内存中，以更小的页粒度为单位装入更多更大的程序，可以采用自动的虚拟存储技术。
  

### 覆盖技术

**目标**

是在较小的可用内存中运行较大的程序。常用于多道程序系统，与分区存储管理配合使用。
**原理**

把程序按照其自身逻辑结构，划分为若干个功能上相互独立的程序模块，那些不会同时执行的模块共享同一块内存区域，按时间先后来运行。

* 必要部分（常用功能）的代码和数据常驻内存；
* 可选部分（不常用功能）在其他程序模块中实现，平时存放在外存中，在需要用到时才装入内存；
* 不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖，即这些模块共用一个分区。
  

### 交换技术

**目的**

多道程序在内存时，让正在运行的程序或需要运行的程序获得更多的内存资源。
**方法**

* 可将暂时不能运行的程序送到外存，从而获得空闲内存空间。
* 操作系统把一个进程的整个地址空间的内容保存到外存中（换出 swap out），而将外存中的某个进程的地址空间读入到内存中（换入 swap in）。 换入换出内容的大小为整个程序的地址空间。

**覆盖技术和交换技术的比较**
**特点**

覆盖只能发生在那些相互之间没有调用关系的程序模块之间，因此程序员必须给出程序内的各个模块之间的逻辑覆盖结构。
交换技术是以在内存中的程序大小为单位进行的，它不需要程序员给出各个模块之间的逻辑覆盖结构。
换言之，交换发生在内存中程序与管理程序或操作系统之间，而覆盖则发生在运行程序的内部。
在内存不够用的情形下，可以采用覆盖技术和交换技术，但是：

**覆盖技术**：需要程序要自己把整个程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，增加了程序员的负担。
**交换技术**：以进程作为交换的单位，需要把进程的整个地址空间都换入换出，增加了处理器的开销。
“四海之内” 解决之道：虚拟内存管理技术——虚存技术 ↓

### 虚拟技术

#### 虚拟页式内存管理

![image-20240705144300989](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240705144300989.png)

![image-20240705144413966](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240705144413966.png)

> 修改位如果为零表示不用再写入硬盘，直接清空即可；需要的时候再从硬盘写入内存了；如果被修改过则还需要将其写回硬盘中去；

**举例**

![image-20240705151621671](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240705151621671.png)

> **缺页中断处理机制**

![image-20240705151849227](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240705151849227.png)

> **后备存储**

在何处保存未被映射的页?

1. 能够简单地识别在二级存储器中的页
2. 交换空间(磁盘或者文件):特殊格式，用于存储未被映射的页面

概念:后备存储 backing store

1. 一个虚拟地址空间的页面可以被映射到一个文件(在二级存储中)中的某个位置
2. 代码段:映射到可执行二进制文件
3. 动态加载的共享库程序段:映射到动态调用的库文件
4. 其它段:可能被映射到交换文件(swapfle)——>在硬盘上的换入换出分区

#### 虚拟内存性能

![image-20240705160716421](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240705160716421.png)

#### 页面置换算法

**最优页面置换算法（OPT）**

> 最优页面置换算法（OPT，optimal）

基本思路：当一个缺页中断发生时，对于保存在内存当中的每一个逻辑页面，计算在它的下一次访问之前，还需等待多长时间，从中选择等待时间最长的那个，作为被置换的页面。

这是一种理想情况，在实际系统中是无法实现的，因为操作系统无法知道每一个页面要等待多长时间以后才会再次被访问。

可用作其他算法的性能评价的依据。（在一个模拟器上运行某个程序，并记录每一次的页面访问情况，在第二遍运行时即可使用最优算法）

**先进先出算法（FIFO）**

> 先进先出算法（FIFO，First-In First-Out）

基本思路：选择在内存中驻留时间最长的页面淘汰。 具体来说，系统维护着一个链表，记录了所有位于内存当中的逻辑页面。 从链表的排列顺序来看，链首页面的驻留时间最长，链尾页面的驻留时间最短。 当发生一个缺页中断时，把链首页面淘汰出去，并把新的页面添加到链表的末尾。

性能较差，调出的页面有可能是经常要访问的页面。 并且有Belady现象。 FIFO算法很少单独使用。
![image-20240705174548067](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240705174548067.png)

**最近最久未使用算法（LRU）**

> 最近最久未使用算法（LRU，Least Recently Used）

基本思路：当一个缺页中断发生时，选择最久未使用的那个页面，并淘汰。

它是对最优页面置换算法的一个近似，其依据是程序的局部性原理，即在最近一小段时间）最近几条指令）内，如果某些页面被频繁地访问，那么再将来的一小段时间内，他们还可能会再一次被频繁地访问。 反过来说，如果过去某些页面长时间未被访问，那么在将来它们还可能会长时间地得不到访问。
![image-20240705184924227](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240705184924227.png)

 **时钟页面置换算法（Clock）**

> Clock页面置换算法，LRU的近似，对FIFO的一种改进；

基本思路

需要用到页表项的访问位(access bit)，当一个页面被装入内存时，把该位初始化为 0 00。 然后如果这个页面被访问，则把该位置设为 1 11;

把各个页面组织成环形链表（类似钟表面），把指针指向最老的页面（最先进来）;

当发生一个缺页中断时，考察指针所指向的最老页面，

➢ 若它的访问位为 0 00，立即淘汰；

➢ 若访问位为 1 11，则访问位置为 0 00，然后指针往下移动一格。

➢ 如此下去，直到找到被淘汰的页面，然后把指针移动到下一格。

示例

维持一个环形页面链表保存在内存中

➢ 用一个时钟（或者使用 / 引用）位来标记一个页面是否经常被访问

➢ 当一个页面被引用的时候，这个位被设置（为1）

时钟头扫遍页面寻找一个带有 u s e d   b i t = 0   ( a s s e s s   b i t ) used\ bit=0\ (assess\ bit)used bit=0 (assess bit)

➢ 替换在一个周转内没有被引用过的页面

![image-20240705195533449](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240705195533449.png)

![image-20220521184830591](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/73cc966291e1aa3da3c2e0e90c1f0b76.png)

![image-20240705210330795](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240705210330795.png)

**二次机会算法（Enhanced Clock）**

> 改进的Clock算法（Enhanced Clock）

这里有一个巨大的代价来替换“脏”页

修改Clock算法，使它允许脏页总是在一次时钟头扫描中保留下来

➢ 同时使用脏位和使用位来指导置换

因为考虑到时钟页面置换算法，有时候会把一些 d i r t y   b i t dirty\ bitdirty bit 为 1 11（有过写操作）的页面进行置换，这样的话，代价会比较大。

因此，可以结合使用位和脏位一起来决定应该置换哪一页。

![image-20220521194119623](https://img-blog.csdnimg.cn/img_convert/443cb9941d35c05b1bc7a412901f3b9d.png#pic_center)

![image-20220521195459100](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/0e2bf777c301a5bf11406dfb68cfefec.png)

**最不常用算法（LFU）**

> 最不常用算法（LFU，Least Frequently used）

基本思路：当一个缺页中断发生时，选择访问次数最少的那个页面，并淘汰。

实现方法：对每一个页面设置一个访问计数器，每当一个页面被访问时，该页面的访问计数器加1。 当发生缺页中断时，淘汰计数值最小的那个页面。

LRU和LFU的对比：LRU考察的是多久未访问，时间越短越好；而LFU考察的是访问的次数或频度，访问次数越多越好。

#### Belady现象

* 在采用FIFO算法时，有时会出现分配的物理页面数增加，缺页率反而提高的异常现象；

* 原因：FIFO算法的置换特征与进程访问内存的动态特征是矛盾的，与置换算法的目标是不一致的）即替换较少使用的页面），因此，被他置换出去的页面不一定是进程不会访问的。

**FIFO算法有Belady现象**

`gif`示例，物理页面数为 3 ：

#### 局部页替换算法的问题、工作集模型

##### 工作集

![image-20240705235717502](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240705235717502.png)

**示例**

![image-20220521221324270](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/973db2c652fd2be67acf1512d5419411.png)

**常驻集**
常驻集是指在**当前时刻，进程实际驻留在内存当中的页面集合。**

工作集与常驻集的关系

➢ 工作集是进程在运行过程中固有的性质

➢ 常驻集取决于系统分配给进程的物理页面数目和页面置换算法

![image-20240706002056687](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240706002056687.png)

缺页率与常驻集的关系

➢ 常驻集 ⊇ ⊇⊇ 工作集时（一个进程的整个工作集都在内存当中），缺页较少

➢ 工作集发生剧烈变动（过渡）时，缺页较多

➢ 进程常驻集大小达到一定数目后，再给它分配更多的物理页面，缺页率也不会明显下降

**工作集页置换算法**
**思路**
	换出不在工作集中的页面
**窗口大小 Π**
当前时刻前 Π 个内存访问的页引用是工作集，  Π 被称为窗口大小
**实现方法**
访存链表：维护窗口内的访存页面链表

访存时，换出不在工作集的页面；更新访存链表

缺页时，换入页面；更新访存链表

#### 全局页面置换算法

1.工作集页置换算法

➢ 示例：

![image-20240706003010423](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240706003010423.png)

这种窗口大小是固定的，因此想要动态改变工作集大小，引出了

**缺页率页面置换算法**

**可变分配策略**：常驻集大小可变。 例如：每个进程在刚开始运行的时候，先根据程序大小给它分配一定数目的物理页面，然后在进程运行过程中，再动态地调整常驻集的大小。

可采用全局页面置换的方式，当发生一个缺页中断时，被置换的页面可以是在其他进程当中，各个并发进程竞争地使用物理页面。
优缺点：性能较好，但增加了系统开销。
具体实现：可以使用==缺页率算法（PFF，page fault frequency）==来动态调整常驻集的大小。
**缺页率（page fault rate）**
表示 “缺页次数 / 内存访问次数”（比率）或 “缺页平均时间间隔的倒数”。

**影响缺页率的因素**

页面置换算法
分配给进程的物理页面数目
页面本身的大小
程序的编写方法

**算法实现**
保持追踪缺失发生概率。

* 访存时，设置引用位标志
* 缺页时，计算从上次缺页时间$t_{last}$ 到现在 $t_{current}$的时间间隔

➢ 如果发生页缺失之间的时间是“大”的，之后减少工作集。

➢ 如果 $t_{current}-t_{last}> T $，则置换所有在$ [t_{current}-t_{last}]$时间内没有被引用的页。

➢ 如果这个发生页缺失的时间是“小”的，之后增加工作集。

➢ 如果 $t_{current}-t_{last}\leqslant T $，则增加缺失页到工作集中。

![img](https://raw.githubusercontent.com/Linff214/picodemo/master/img/de1f46bd27c0299bd04bd3b449ad1209.png)

#### 抖动问题

> 工作集、常驻集概念的拓展

* 抖动

➢ 如果分配给一个进程的物理页面太少，不能包含整个的工作集，即常驻集 ⊂ ⊂⊂ 工作集；

➢ 那么进程将会造成很多的缺页中断，需要频繁的在内存与外存之间替换页面；

➢ 从而使进程的运行速度变得很慢，我们把这种状态称为 ”抖动“。

产生抖动的原因

➢ 随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断就减小，缺页率不断上升。

操作系统需要在并发水平和缺页率之间达到一个平衡

➢ 选择一个适当的进程数目和进程需要的物理页面数。

**负载控制**

![image-20220522144746634](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/67a7e6677c5345a6aabcdf4b1412af48.png)

## D进程管理

### 进程描述

#### 进程的定义

- 进程：一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。

  ![image-20220522200555664](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/47885b90d025be86ea34deddc7735500.png)

#### 进程的组成

**一个进程应该包括：**

程序的代码；
程序处理的数据；
程序计数器中的值，指示下一条将运行的指令；
一组通用的寄存器的当前值，堆，栈；
一组系统资源（如打开的文件）
总之，进程包含了正在运行的一个程序的所有状态信息。

**进程和程序的联系**

程序是产生进程的基础
程序的每次运行构成不同的进程
进程是程序功能的体现
通过多次执行，一个程序可以对应多个进程；通过调用关系，一个进程可包括多个程序。

**进程和程序的区别**

进程是动态的， 程序是静态的：程序是有序代码的集合。 进程是程序的执行，进程有**核心态 / 用户态。**核心态是在操作系统中运行，但并没有写操作系统的代码，为什么会有核心态，这是因为进程在执行过程中需要完成某些特定功能,这些功能只能操作系统提供,比如从磁盘读写文件;
进程是暂时的，程序是永久的。 进程是一个状态变化的过程，程序可以长久保存。
进程和程序的组成不同：进程的组成包括程序，数据和进程控制块（进程状态信息）

**进程的特点**

 动态性：可动态地创建，结果进程；

并发性：进程可以被独立调度并占用处理机运行；（并发：一段，并行：一时刻）

独立性：不同进程的工作不相互影响；（页表是保障措施之一）

制约性：因访问共享数据 / 资源或进程间同步而产生制约。

![image-20240706134852906](https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240706134852906.png)

#### 进程的特点



#### 进程控制结构

### 进程状态

### 线程

### 进程间通信

### 进程互斥不同步

### 死锁
